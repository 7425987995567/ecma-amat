# Cпецификация языка ECMAScript 2015

# 1 Область применения

Этот стандарт определяет язык ECMAScript 2015.

# 2 Соблюдение спецификации

Соблюдающая этот стандарт реализация ECMAScript обязана предоставлять и поддерживать все типы, значения, объекты, свойства, функкции
и программный синтаксис и семантику, описанную в данной спецификации

Соблюдающая реализация должна интерпретировать входной исходный текст в соответствии с Юникодом (версии 5.1.0 или позднее) и ISO/IEC
10646. Если принятое подмножество ISO/IEC 10646 не определено иначе, предполагается что это множество Юникода, коллекция 10646.

Соблюдающая реализация, которая предоставляет прикладной программный интерфейс, который поддерживает программы, которые должны
адаптироваться к лингвистическим и культурным соглашениям, используемыми разными человеческими языками и странами, должна реализовать
интерфейс, определенный в самой новой версии ECMA-402, поддерживаемой данным стандартом.

Соблюдающая реализация может может предоставлять дополнительные типы, значения, объекты, свойства и функции, кроме тех, которые
определены в данной спецификации. В частности, соблюдающая реализация может предоставлять свойства, не описанные в данной спецификации,
и значения для этих свойств для объектов, описанных в данной спецификации.

Соблюдающая реализация может поддерживать дополнительный программный синтаксис и регулярные выражения, не описанные в данной спецификации.
В частности, соблюдающая реализация может может поддерживать программный синтаксис, который использует "зарезервированные на будущее
слова" из 11.6.1.1 данной спецификации.

Соблюдающая реализация не должна реализовывать никакое из расширений, перечисленных в списке запрещенных расширений в 16.1

# 3 Нормативные спецификации
Следующие нормативные документы необходимы для реализации данной спецификации. Если они обозначены датой, то самая последняя
совместимая версия должна использоваться, если не обозначены датой - то просто должна использоваться самая последняя версия.

Эти стандарт: ISO/IEC 10646, ECMA-402, ECMA-404.

# 4 Обзор
В этой секции содержится НЕнормативное описание ECMAScript (ЭС).

ЭС - это объектно-ориентированный язык программирования для произведения вычислений и манипулирования объектами вычислений в пределах хост-окружения. ЭС, как он описан здесь, не предполагается вычислительно-полным: и впрямь, в этой спецификации никак не описываются ВВОД данных в программу и ВЫВОД данных из программы. Ожидается, что реализация вычислительного окружения программы на ЭС предоставит не только объекты и иные вещи, описание которых содержится в данной спецификации, но и иные специфичные для окружения объекты, описание и поведение которых - вне этой спецификации, кроме того уточнения, что эти специфичные для окружения средства могут предоставлять некоторые свойства и функции, к которым можно будет обратиться из программы на ЭС.

ЭС изначально задумывался как скриптовый язык, но его стали широко использовать в качестве языка общего назначения. Скриптовым языком называется язык, который используется для манипуляции, кастомизации и автоматизации средств существующей системы. В таких системах уже доступна через пользовтельский интерфейс всяческая полезная функциональность, а скриптовый язык - это средства, с помощью которого эта функциональность может управляться программно. В данном случае говодят, что система предоставляет хост-окружение из объектов и иной функциональности, которые и определяют возможности скриптового языка. Скриптовый язык задумывается как язык для использования, как профессионалами, так и просто пользователями.

ЭС изначально задумывался как веб-скриптовый язык, предоставляя механизм для оживления веб-страниц в браузерах и для выполнения серверных вычислений в рамках веб-архитектуры клиент-сервер. ЭС сейчас используется для того, чтобы предоставить базовые скриптовые возможности для целого ряда хост-окружений. Поэтому язык ЭС описан в этой спецификации без привязки к хост-окружениям.

ЭС отошел от чистого скриптинга и теперь широко используется для самых различных общих программных задач различных окружений и масштабов. Как расширялась область использования ЭС, так расширялось и множество возможностей, которые он предоставляет. Поэтому сейчас ЭС - это полноценный язык программирования общего назначения.

Некоторые возможности ЭС подобны возможностям иных языков, в частности Си, Джавы, Self и Scheme. Они описаны в ISO/IEC 9899:1996, "Спецификации языка Джава", статье "Self. Сила простоты", IEEE-стандарте языка Scheme.

# 4.1 Веб-скриптинг
Веб-браузер предоставляет ЭС хост-окружение для клиентских вычислений, включая объекты, которые представляют из себя абстракцию окон, меню, попапов, диалоговых окон, текстовых полей, ссылок, фреймов, истории, куков и ввода-вывода. Также хост-окружение предоставляет возможности для выполнения вычислений при таких событиях, как смена фокуса, загрузка и выгрузка страницы или изображения, ошибка и отмена, заполнение формы, выбор элемента и действия мышью. Скриптовый код, который существует в ХТМЛ а отображаемая страница - это совокупность элементов пользовательского интерфейса и фиксированных или вычисленных текста и картинок. Скриптовый код реагирует на действия пользователя и поэтому нет нужны в главной процедуре.

Сервер представляет собой другое хост-окружения для серверных вычислений, включающее объекты для описания запросов, клиентов и файлов, а также механизмы для обособления и общего доступа к данным. Используя как клиентские, так и серверные вычисления, можно распределить вычислительную нагрузку между клиентом и сервером, предоставляя в результате ксатомизированное под пользователя веб-приложение.

Каждый браузер и сервер, который поддерживает ЭС, предоставляет свое собственное хост-окружение, заключающее в себя среду выполнения ЭС.

# 4.2 Обзор ЭС
Сейчас пойдет неформальное описание ЭС - в нем описано не всё. Обзор не является собственно частью стандарта.

ЭС объектно-ориентированный: как специфицированные возможности ЭС, так и возможности хост-окружения предоставляются в виде объектов. Программа ЭС - это кластер сообщающихся объектов. В ЭС любой объект - это совокупность свойств и атрибутов , атрибуты определяют как свойство можно использовать - например, если атрибут Writable у свойства выставлен в false, то зафейлится любая попытка присвоить этому свойству другое значение. Свойства - это контейнеры. в которыых содержатся другие объекты, примитивные значения и функции. Примитивное значение - это член одного из слеующих встроенных типов: Undefined, Null, Boolean, Number, String или Symbol; объект - это член встроенного типа Object, а функция - это вызываемый объект. Функция, ассоциированная с объектом через свойство называется методом.

ЭС предоставляет совокупность встроенных объектов, которые заключют в себе всю спецификацию ЭС. Эти встроенные объекты включают глобальный объект, объекты, которые фундаментальны для семантики времени выполнения, такие как Object, Function, Boolean, Symbol, различные объекты Error, объекты, которые содержат числовые значения или манипулируют ими, как Math, Number, Date, объекты для обработки строк - String, RegExp, объекты, которые есть индексированные совокупности значений, такие как Array и 9 типов Typed Arrays (типизированных массивов), элементы которых имеют специфичное представление числовых данных, коллекции с доступом по ключу, такие как объекты Set и Map? объекты для поддержки структурированных данных, такие как объекты JSON, ArrayBuffer, DataView, объекты для поддержки управления абстракциями, такие как функции-генераторы и объекты Promise, объекты рефлексии Proxy, Reflect.

ЭС также определяет множество встроенных операторов. Операторы ЭС включают в сеюя множество унарных операторов, мультипликативных операторов, операторов сложения, операторов побитового сдвига, операторов отношений, операторов равенства, бинарных побитовых операторов, бинарных логических операторов, операторов присваивания, оператора-запятой.

Для больших программ на ЭС существуют модули, которые позволяют разделить программу на множественные последовательности выражений и объявлений. Каждый модуль явно определяет объявления, которые он использует из других модулей, и определяет, какие из его собственных объявлений будут доступны в других модулях.

Синтаксис ЭС намеренно похож на синтаксис джавы. Синтаксис ЭС нестрогий, это сделано для того, чтобы пользоваться им было легко. Например, для переменной необязательно, чтобы при её объявлении указывался ее тип, типы также не применяются к свойствам, а определения функций не должны содержать текстовые объявления типов в своём объявлении перед вызовом этих функций.

# 4.3 Объекты
Даже хотя ЭС и поддерживает синтаксис для определения классов, объекты ЭС фундаментально НЕ базируются на классах, как объекты в плюсах, Smalltalk или джаве. Вместо этого, объекты могут быть созданы многими способами, включая использование литеральной нотации или через конструкторы, которые создают объекты, а потом выполняют код, который инициализирует все их части, присваивая начальные значения их свойствам. Каждый конструктор - это функция, у которой есть специальное свойство prototype, которое используется для prototype-based inheritance (наследования по прототипу) и используется для общих свойств. Объекты создаются, если использовать конструктор с ключевым словом new, например, new Date(2009,11) создаёт новый объект Date. Вызов функции-конструктора без использования ключевого слова new имеет последствия, зависящие от данного конкретного конструктора. Например, вызов Date() производит текстовую репрезентацию текущей даты и времени, а не объект Date.

Каждый объект, созданный конструктором, содержит неявную ссылку (которая называется прототипом объекта), эта ссылка - ссылка на значение свойства prototype создавшего его конструктора. Более того, prototype, будучи объектом, может содержать ссылку на на иной prototype, и так далее, это называется цепочкой прототипов. Когда обращаются к некоторому свойству некоторого объекта А, обращение идёт к первому свойству с таким именем у некоторого объекта В в цепочке прототипов объекта А, если у объекта В есть свойство с таким именем. Иными словами, сначала сам объект А будет исследован на наличие свойства с таким именем, если у объекта А есть свойство с таким именем, то возвращается значение этого свойства, если у объекта А нет свойства с таким именем, то исследуется прототип объекта А и так далее.

В объектно-ориентированном языке, базирующемся на классах, в общем, сущности (instances) класса несут состояние, классы есть носители методов, а наследование касается лишь структуры и поведения. В ЭС объекты несут состояние и методы, а наследуются и поведение, и состояние, и структура.

Все объекты, которые напрямую не имеют данного свойства, но которые имеют данное свойство в некотором прототипе А, шарят (share) данное свойство и его значение. Проиллюстрируем это:

![alt](https://github.com/7425987995567/ecma-amat/blob/master/images/x1Alwp2UGTY.jpg)

CF - это функция-конструктор (а так как функции являются объектами, то CF - объект). Используя выражение new CF() были созданы пять объектов: cf1, cf2, cf3, cf4, cf5. У каждого из объектов cf1 - cf5 есть свойства q1 и q2. Штриховая линия показывает на прототип объекта: так, например, прототип cf3 - это CFP. CF (конструктор) сам имеет два свойства P1, P2 - эти свойства не видимы (не доступны) через CFP, cf1, cf2, cf3, cf4, cf5. Объекты cf1, cf2, cf3, cf4, cf5 шарят свойство CFP1 объекта CFP, но CF не шарит это свойство - оно не видимо через CF. Объекты cf1, cf2, cf3, cf4, cf5 также шарят все свойства из неявной ссылки (прототипа объекта) CFP, кроме свойств с именами CFP1, q1, q2. Заметьте, что между CF и CFP нет неявной ссылки.

(прим. перевода - также заметьте, что все пять объектов cf1, cf2, cf3, cf4, cf5 имеют свои собственные свойства q1, q2, например, q1 в cf1 не имеет никакой связи со свойствами q1 cf2, cf3, cf4, cf5).

В отличие от большинства языков, где наследование базируется на классах, свойства могут быть динамически добавлены в объект, если по ссылке на несуществующее свойство присвоить некоторое значение. То есть, конструкторы не обязаны называть любые свойства или присваивать значения любым свойствам созданных ими объектов. В рисунке выше, можно добавить в CFP новое свойство (присвоив ему некоторое значение) и это свойство будут шарить cf1, cf2, cf3, cf4, cf5 автоматически.

Хотя объекты ЭС по наследованию НЕ наследуются ни от каких классов, часто бывает удобно определить подобные на "класс" абстракции при помощи паттерна проектирования с помощью функций-конструкторов, прототипы объектов и методы. Встроенные в ЭС объекты сами следуют такому паттерну. Начиная с ЭС 2015, язык ЭС включает в себя синтаксическое определение class, чтобы можно было определять объекты согласно такому паттерну, какой используют и встроенные в ЭС объекты.

# 4.2.2. Строгий вариант языка ЭС
Язык ЭС признает тот факт, что некоторые пользователи языка хотели бы ограничить себя от использования некоторых возможностей языка. Они могут это делать из соображений безопасности, чтобы избечь тех особенностей ЭС, которые они считают в ЭС часто приводящими к ошибкам во время разработки, чтобы использовать утилиты для автоматической проверки на ошибки, а также из-за любых других причин. Чтобы поддержать таких пользователей, ЭС имеет строгий вариант. Строгий вариант исключил некоторые специфические синтаксические и семантические особенности обычного языка ЭС, а так же модифицирует несколько семантику некоторых иных особенностей языка. Строгий вариант также определяет дополнительные условия для выбрасывания исключений, в ситуациях, которые в обычном ЭС не считаются ошибочными.

Строгий вариант ЭС обычно называют стриктмодом (strict mode) языка ЭС. Выбор стриктмода и использование строго варианта ЭС явно определяется в начале индивидуального файла с ЭС-кодом, если в этом файле автор решил использовать стриктмод. Так как стриктмод выбирается на уровне отдельного файла с кодом, то и действует он только в пределах данного файла. Стриктмод никак не влияет на семантику тех особенностей ЭС, которые должны использоваться при взаимодействии файлов с кодом ЭС. Программа ЭС может быть составлена из файлов с кодом, где некоторые файлы используют стриктмод, а некоторые - нет. В этом случае стриктмод используется только для исполнения файлов, которые написаны в стриктмоде.

Чтобы соответствовать этой спецификации, любая реализация языка ЭС обязана должна реализовать как обычный ЭС, так и стриктмод. А также реализация должна реализовать возможность запуска и стриктмод, и обычных файлов с ЭС кодом в пределах одной программы.

# 4.3 Термины и определения
Для этого документа используются следующие термины и определения

# 4.3.1 тип
множество значений информации, определенное в пункте 6 данной спецификации

# 4.3.2 примитивное значение
член одного из следующих типов: Undefined, Null, Boolean, Number, Symbol, String, как они определены в пункте 6.

Замечание: примитивное значение - это информация, которая представлена напрямую на самом низком уровне реализации языка.

# 4.3.3 объект
член типа Object.

Замечание: объект - это коллекция свойств с единственным прототипом объекта. Прототип объекта может быть null.

# 4.3.4 конструкция
функция, которая создаёт и инициализирует объекты

Замечание: Значение свойства prototype функции-конструктора - это объект, который используется для реализации наследования и свойств, которые шарят все объекты, созданные данным конструктором.

# 4.3.5 прототип
(ака прототип объекта)

объект, свойства которые шарятся другими объектами.

Замечание: Когда конструктор создаёт объект, то созданный объект неявно ссылается на свойство prototype функции-конструктора для тех целей, чтобы разрешать ссылки на свойства, которые у него явно отсутствуют. Свойство конструктора А под именем prototype доступно по обращению A.prototype. Свойства, добавленные в прототип объекта шарятся всеми объектами у которых этот прототип. Иным образом, новый объект может быть создан с явно указанным объектом для прототипа через функцию Object.create 

# 4.3.6 обычный объект
объект с обычным поведением для всех необходимых внутренних методов, которые должны поддерживаться всеми объектами.

# 4.3.7 экзотический объект
объект, у которого поведение хотя бы для одного из необходимых внутренних методов для всех объектов отличается от того поведения, которое должно быть у всех объектов.

Замечание: любой объект, который не является обычным объектом, является экзотическим объектом.

# 4.3.8 стандартный объект
объект, чья семантика определена в данной спецификации

# 4.3.9 встроенный объект
объект, специфицированный и предоставленный спецификацией ЭС

Замечание: Стандартные встроенные объекты определены в данной спецификации. Спецификация ЭС может специфицировать и предоставить дополнительные виды встроенных объектов. Встроенный конструктор - это встроенный объект, который является конструктором.

# 4.3.10 значение undefined
примитивное значение, которое имеет переменная, когда ей не присвоили никакого значения.

# 4.3.11 тип Undefined
тип, единственным членом которого является undefined.

# 4.3.12 значение null
примитивное значение, которое представляет из себя намеренное отсутствие любого значения объекта

# 4.3.13 тип Null
тип, единственным членом которого является null.


